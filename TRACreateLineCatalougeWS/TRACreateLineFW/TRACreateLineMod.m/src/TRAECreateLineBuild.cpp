// COPYRIGHT Dassault Systemes 2022
//===================================================================
//
// TRAECreateLineBuild.cpp
// Provide implementation to interface
//    CATIBuild
//
//===================================================================
//
// Usage notes:
//
//===================================================================
//  Jan 2022  Creation: Code generated by the CAA wizard  Dell
//===================================================================
#include "TRAECreateLineBuild.h"

#include "CATGeoFactory.h"
#include "CATISpecObject.h"
#include "TRAICreateLineClass.h"
#include "CATIGeometricalElement.h"
#include "CATDocument.h"
#include "CATIContainerOfDocument.h"
#include "CATIContainer.h"
#include "CATBody.h"
#include "CATTopData.h"
#include "CATTopLineOperator.h"
#include "CATIMfProcReport.h"
#include "CATMmrAlgoConfigServices.h"
 
CATImplementClass(TRAECreateLineBuild,
                  DataExtension,
                  CATBaseUnknown,
                  CreateLine );
 

//-----------------------------------------------------------------------------
// TRAECreateLineBuild : constructor
//-----------------------------------------------------------------------------
TRAECreateLineBuild::TRAECreateLineBuild():
    CATBaseUnknown()
{
}

//-----------------------------------------------------------------------------
// TRAECreateLineBuild : destructor
//-----------------------------------------------------------------------------
TRAECreateLineBuild::~TRAECreateLineBuild()
{
}
 
// Link the implementation to its interface
// ---------------------------------------



//TIE or TIEchain definitions
#include "TIE_CATIBuild.h"
#include "CATMfErrUpdate.h"
#include <iostream>
#include "CATCGMJournalList.h"
#include "CATSoftwareConfiguration.h"


using namespace std;

TIE_CATIBuild( TRAECreateLineBuild);


//Methods implementation

//-----------------------------------------------------------------------------
// Implements CATIBuild::Build
//-----------------------------------------------------------------------------
HRESULT TRAECreateLineBuild::Build ()
{

	HRESULT rc = E_FAIL ;

   CATGeoFactory_var      piGeomFactory = NULL_var;
   CATGeoFactory* pGeoFact = NULL;
	CATISpecObject    * pSOCreateLine = NULL;
	CATIMfProcReport_var   piProcReport = NULL_var;
	CATSoftwareConfiguration * pSoftConfig = NULL;
	CATBody_var spiBodyOfPoint1,spiBodyOfPoint2 ;
	CATCGMJournalList *pCGMJournalList = NULL;
	int IsConfigToStore = NULL;

	CATTry 
    {



   // -2-1 Retrieving the two input points

	CATISpecObject    *piSpecOnPoint1     = NULL;
    CATISpecObject    *piSpecOnPoint2     = NULL;

	TRAICreateLineClass *piCreatLine = NULL;
          rc = QueryInterface( IID_TRAICreateLineClass , (void**) &piCreatLine );
          if ( SUCCEEDED(rc) )
          {
             // Retrieves Point
             rc = piCreatLine->GetPoint    ( 1 , &piSpecOnPoint1     );
             if ( SUCCEEDED(rc) )
                rc = piCreatLine->GetPoint( 2 , &piSpecOnPoint2 );

			 piCreatLine->Release();
             piCreatLine = NULL ;

			  if ( FAILED(rc) )
             {
                // One of the inputs is NULL 
                if ( NULL != piSpecOnPoint1 )
                {
                   piSpecOnPoint1->Release();
                   piSpecOnPoint1 = NULL;
                }
                if ( NULL != piSpecOnPoint2 )
                {
                   piSpecOnPoint2->Release();
                   piSpecOnPoint2 = NULL;
                }

				 // An error is created 
                CATMfErrUpdate *pErrorNoValidInput = new CATMfErrUpdate();
                CATUnicodeString Diagnostic("One of the inputs is wrong.");
                pErrorNoValidInput->SetDiagnostic(1,Diagnostic);

                CATThrow(pErrorNoValidInput);
             }
          }

          // -2-3 Retrieving the two bodies corresponding to the two input Points

		  

          if ( SUCCEEDED(rc) && (NULL !=piSpecOnPoint1) )
          {
             // gets a pointer on CATIGeometricalElement on the first input curve
             CATIGeometricalElement *piGeometricalElementOnPoint1 = NULL;
             rc = piSpecOnPoint1->QueryInterface ( IID_CATIGeometricalElement , 
                                                (void**) &piGeometricalElementOnPoint1 );
    
             if ( SUCCEEDED(rc) )
             {
                // uses GetBodyResult to retrieve the first body
                spiBodyOfPoint1 = piGeometricalElementOnPoint1->GetBodyResult();
    
                // releases useless pointer on CATIGeometricalElement
                piGeometricalElementOnPoint1->Release();
                piGeometricalElementOnPoint1 = NULL ;
             }
          }

          if ( SUCCEEDED(rc) && (NULL !=piSpecOnPoint2) )
          {
             // gets a pointer on CATIGeometricalElement on the second input curve
             CATIGeometricalElement *piGeometricalElementOnPoint2 = NULL;
             rc = piSpecOnPoint2->QueryInterface ( IID_CATIGeometricalElement , 
                                                   (void**) &piGeometricalElementOnPoint2 );
    
             if ( SUCCEEDED(rc) )
             {
                // uses GetBodyResult to retrieve the second body
                spiBodyOfPoint2 = piGeometricalElementOnPoint2->GetBodyResult();
    
                // releases useless pointer on CATIGeometricalElement
                piGeometricalElementOnPoint2->Release();
                piGeometricalElementOnPoint2 = NULL ;
				 
             }
          }

		  
		   // -3-1 Filling the lists of the specifications to follow by the procedural report
         //      
         //======================================================================================

          CATLISTV(CATBaseUnknown_var) ListSpec;
          CATListOfCATUnicodeString    ListKeys;
          if ( SUCCEEDED(rc) )
          {
                ListSpec.Append( piSpecOnPoint1     ); 
                ListKeys.Append( "MfKeyNone"          );

				ListSpec.Append( piSpecOnPoint2 ); 
                ListKeys.Append( "MfKeyNone"          );

		  }

		  // No more need of those pointers 
          if ( NULL != piSpecOnPoint1 )
          {
             piSpecOnPoint1->Release();
             piSpecOnPoint1 = NULL;
          }
          if ( NULL != piSpecOnPoint2 )
          {
             piSpecOnPoint2->Release();
             piSpecOnPoint2 = NULL;
          }

		   // Once the pointers are released, Checking that the bodies of the      
         // curve exist
         //
         if ( SUCCEEDED(rc) )
         {
            if ( (NULL_var == spiBodyOfPoint1 ) || ( NULL_var == spiBodyOfPoint2) )
            {
                // An error is created 
                CATMfErrUpdate *pErrorNoValidInput = new CATMfErrUpdate();
                CATUnicodeString Diagnostic("One of the curve has no topology.");
                pErrorNoValidInput->SetDiagnostic(1,Diagnostic);

                CATThrow(pErrorNoValidInput);
            }
         } 


		  // -3-2 Creating the procedural report with the list
         //     
         //======================================================================================

          if ( SUCCEEDED(rc) )
          {
             rc = QueryInterface( IID_CATIMfProcReport , (void**) &piProcReport );
             if ( SUCCEEDED(rc) )
             {
                // Creates the procedural report- the result is associated with the
                // feature itself - so BoolOper is 0
                // This method can throw an error
                //
                int BoolOper = 0;
                piProcReport->CreateProcReport(ListSpec,ListKeys,BoolOper); 
				
				//piProcReport=this;
			 }

             }
          }


		   // -4-2 Retrieving the topological journal which contains the description
          //      of all basic topological operations.
          //
          //=====================================================================================

          CATTopData TopData ;
          if ( SUCCEEDED(rc) && (NULL_var!=piProcReport) )
          {
             // do not release this pointer
             // This method can throw an error
            
             
          //=====================================================================================
          //
          // -4-3 Retrieving the Algorithm Configuration which contains datas used to
          //      version features
          //
          //=====================================================================================
             rc = QueryInterface(IID_CATISpecObject,(void **) & pSOCreateLine);
             if(SUCCEEDED(rc)&&pSOCreateLine != NULL)
             {
                rc = CATMmrAlgoConfigServices::GetConfiguration(pSOCreateLine ,pSoftConfig ,IsConfigToStore);
                if(SUCCEEDED(rc))
                {
		               // SetSoftwareConfig	
		               TopData.SetSoftwareConfiguration(pSoftConfig) ;
		               // release pSoftConfig after the procedural report ending
                }
		         }

			 pCGMJournalList = piProcReport->GetCGMJournalList();  
             TopData.SetJournal(pCGMJournalList) ;
          }


	// -4-1 Retrieving the geometrical factory

		   //if ( SUCCEEDED(rc) )
     //     {
     //        // Gets a pointer on CATISpecObject.
     //        CATILinkableObject *piLinkableObjectOnCreateLine = NULL;
     //        rc = QueryInterface( IID_CATILinkableObject, 
     //                             (void**)& piLinkableObjectOnCreateLine );
     //     
     //        if ( SUCCEEDED(rc) )
     //        {
     //           // Do not release this pointer
     //           CATDocument * pDocument = NULL ;
     //           pDocument = piLinkableObjectOnCreateLine->GetDocument();
   
     //           if ( NULL != pDocument )
     //           {
     //              CATIContainerOfDocument * pIContainerOfDocument = NULL ;
     //              rc = pDocument->QueryInterface(IID_CATIContainerOfDocument, 
     //                                                 (void**)& pIContainerOfDocument );
     //              if ( SUCCEEDED(rc) )
     //              {
     //                 CATIContainer * pIContainerOnGeomContainer = NULL ;
     //                 rc = pIContainerOfDocument->GetResultContainer(pIContainerOnGeomContainer);
     //                 if ( SUCCEEDED(rc) )
     //                 {
					//	   
     //                    rc = pIContainerOnGeomContainer->QueryInterface( IID_CATGeoFactory , 
     //                                                                  (void**) &piGeomFactory );
     //                    pIContainerOnGeomContainer->Release();
     //                    pIContainerOnGeomContainer = NULL ;
     //                 }

     //                 pIContainerOfDocument->Release();
     //                 pIContainerOfDocument = NULL ;
     //              }
     //           }
     //           piLinkableObjectOnCreateLine->Release();
     //           piLinkableObjectOnCreateLine = NULL ;
     //        }
     //     }

		  piProcReport->GetGeoFactoryFromFeature(piGeomFactory);
		   if(!piGeomFactory)
		  {
			  return rc = E_FAIL;
		  }

		  piGeomFactory->QueryInterface( IID_CATGeoFactory , (void**) &pGeoFact );

		 

		   CATTopData*	iTopData = NULL;

		   CATBody   *pResultBody = NULL ;

		      CATTry
		   {

		   

			   /*CATTopLineOperator* pTopLineOperator = NULL;

			   pTopLineOperator =  CATCreateTopLineOperatorFromPoints(piGeomFactory,
												&TopData, spiBodyOfPoint1,spiBodyOfPoint2);*/

			

			   //if ( NULL != pTopLineOperator )
      //       {
      //           // Runs the topological operator
      //           pTopLineOperator->Run();
      //      
      //           // Gets the result of the intersection
      //           pResultBody= pTopLineOperator->GetResult ();             
      //       }

			   if(!pGeoFact)
				   return rc = E_FAIL;
		   pResultBody =  CATCreateTopLineFromPoints(	pGeoFact,
												&TopData, spiBodyOfPoint1,spiBodyOfPoint2);

		   }

		   CATCatch(CATError, pError)
		   {
			   
			   std::cout << pError->GetNLSMessage().ConvertToChar() << std::endl;
		   }

		   CATEndTry;

		   if ( SUCCEEDED(rc) && (NULL_var!=piProcReport)  )
          {
             if ( NULL != pResultBody )
             {
                // This method can throw an error
                int BoolOper = 0 ; // same as CreateProcReport
                piProcReport->StoreProcReport(pResultBody,NoCopy,0); 

				 if(IsConfigToStore == 1)
                {
                   CATMmrAlgoConfigServices::StoreConfiguration(pSOCreateLine ,pSoftConfig);
                }
			 }

			 else
             {
                // creates an error if the intersection failed
                CATMfErrUpdate *pErrorNoIntersection = new CATMfErrUpdate();
                CATUnicodeString Diagnostic("The two extruded curves do not intersect.");
                pErrorNoIntersection->SetDiagnostic(1,Diagnostic);

                CATThrow(pErrorNoIntersection);
             }
		   }




 CATEndTry;

return rc ;
}

